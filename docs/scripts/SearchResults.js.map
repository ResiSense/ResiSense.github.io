{"mappings":"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","sources":["<anon>","scripts/SearchResults.ts","node_modules/fuzzysort/fuzzysort.js"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire8bfa\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire8bfa\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kyWZn\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $a6a072b13f8b7810$export$2e2bcd8739ae039);\n\nvar $gx5Hu = parcelRequire(\"gx5Hu\");\nconst $a6a072b13f8b7810$var$SEARCH_RESULTS_HIGHLIGHT_CLASS = \"highlight\";\nconst $a6a072b13f8b7810$var$searchResultsCache = new Map();\nasync function $a6a072b13f8b7810$var$search(query, searchTargets) {\n    const cacheResult = $a6a072b13f8b7810$var$searchResultsCache.get(query);\n    return [\n        cacheResult ?? await (async ()=>{\n            const compiledResults = await compileSearchResults(query, searchTargets);\n            $a6a072b13f8b7810$var$searchResultsCache.set(query, compiledResults);\n            return compiledResults;\n        })(),\n        cacheResult !== undefined\n    ];\n    //\n    async function compileSearchResults(query, searchTargets) {\n        const compiledResults = [];\n        //! PERFORMANCE\n        const fuzzysortStartTime = performance.now();\n        //! -----------\n        const results = (0, (/*@__PURE__*/$parcel$interopDefault($gx5Hu))).go(query, searchTargets, {\n            keys: [\n                \"title\",\n                \"content\"\n            ],\n            all: true\n        });\n        //! PERFORMANCE\n        const fuzzysortEndTime = performance.now();\n        //! -----------\n        //! PERFORMANCE\n        const compilationStartTime = performance.now();\n        //! -----------\n        results.forEach((result)=>{\n            compiledResults.push({\n                path: result.obj.path,\n                score: result.score,\n                title: result.obj.title.target,\n                highlightedTitleChunks: getHighlighted(query, result[0]),\n                highlightedContentChunks: getHighlighted(query, result[1])\n            });\n        });\n        //! PERFORMANCE\n        const compilationEndTime = performance.now();\n        console.log(\"Fuzzysort took\", fuzzysortEndTime - fuzzysortStartTime, \"ms\");\n        console.log(\"Compilation took\", compilationEndTime - compilationStartTime, \"ms\");\n        //! -----------\n        return compiledResults;\n        //\n        function getHighlighted(query, result) {\n            const OPEN_TAG = `<span class=\"${$a6a072b13f8b7810$var$SEARCH_RESULTS_HIGHLIGHT_CLASS}\">`;\n            const CLOSE_TAG = \"</span>\";\n            // preliminary highlight using fuzzysort highlight function\n            // this only cares about the first match and ignores the rest\n            const preHighlightedTokens = result.highlight((highlightText)=>`${OPEN_TAG}${highlightText}${CLOSE_TAG}`);\n            if (preHighlightedTokens.length === 0) return [];\n            // highlight the rest, atomise them, and push them into the same array\n            const TAGGED_REGEX = new RegExp(String.raw`^${OPEN_TAG}.*${CLOSE_TAG}$`, \"g\");\n            const comprehensiveTokens = getComprehensiveTokens(preHighlightedTokens);\n            const [atomicTokens, tagTokenIndices] = atomiseTokens(comprehensiveTokens);\n            // condense the tokens\n            const condensedTokens = condenseTokens(atomicTokens, tagTokenIndices);\n            return condensedTokens;\n            //\n            function getComprehensiveTokens(inputTokens) {\n                const compTokens = [];\n                inputTokens.forEach((token)=>{\n                    if (token.match(TAGGED_REGEX)) // is tag\n                    compTokens.push(token);\n                    else {\n                        // is sentences\n                        const taggedSentences = highlightMore(token);\n                        const tokenisedHighlightedSentences = tokeniseTaggedSentences(taggedSentences);\n                        compTokens.push(...tokenisedHighlightedSentences);\n                    }\n                });\n                return compTokens;\n                //\n                function highlightMore(text) {\n                    const queries = query.split(\" \").filter((word)=>word.length > 0);\n                    const comprehensiveQueryRegex = new RegExp(String.raw`(${queries.join(\"|\")})`, \"gi\");\n                    return text.replace(comprehensiveQueryRegex, `${OPEN_TAG}$1${CLOSE_TAG}`);\n                }\n                function tokeniseTaggedSentences(taggedSentences) {\n                    const tagSplitRegex = new RegExp(String.raw`(?=${OPEN_TAG})|(?<=${CLOSE_TAG})`, \"g\");\n                    return taggedSentences.split(tagSplitRegex);\n                }\n            }\n            function atomiseTokens(inputTokens) {\n                const tokens = [];\n                const tokenIndices = [];\n                inputTokens.forEach((token)=>{\n                    if (token.match(TAGGED_REGEX)) {\n                        // is tag\n                        tokenIndices.push(tokens.length);\n                        tokens.push(token);\n                    } else // is sentences\n                    tokens.push(...tokeniseSentences(token));\n                });\n                return [\n                    tokens,\n                    tokenIndices\n                ];\n                //\n                function tokeniseSentences(sentences) {\n                    const tokens = sentences.split(/(?<=\\n|\\.\\s|\\?\\s|!\\s)/g).filter((sentence)=>sentence.length > 0);\n                    const paddedTokens = replaceNewlinesWithEmptyElements(tokens);\n                    return paddedTokens;\n                    //\n                    function replaceNewlinesWithEmptyElements(tokens) {\n                        for(let i = 0; i < tokens.length; i++){\n                            const splitTokens = tokens[i].split(\"\\n\");\n                            if (splitTokens.length > 1) {\n                                const withEmptyElements = interweaveEmptyElements(splitTokens);\n                                tokens.splice(i, 1, ...withEmptyElements);\n                                i += withEmptyElements.length - 1;\n                            }\n                        }\n                        return tokens;\n                    }\n                    function interweaveEmptyElements(splitTokens) {\n                        const interweaved = [];\n                        for(let j = 0; j < splitTokens.length; j++){\n                            interweaved.push(splitTokens[j]);\n                            if (j < splitTokens.length - 1) interweaved.push(\"\");\n                        }\n                        return interweaved;\n                    }\n                }\n            }\n            function condenseTokens(inputTokens, tagIndices) {\n                const condensedTokens = [];\n                let condensedTokenIndex = 0;\n                while(condensedTokenIndex < inputTokens.length){\n                    let currentCondensedToken = \"\";\n                    let position;\n                    while(isTruthy(position = tokenIsTagOrAdjacentToTag(condensedTokenIndex))){\n                        const token = inputTokens[condensedTokenIndex];\n                        if (token === undefined) break;\n                        condensedTokenIndex++;\n                        //\n                        currentCondensedToken += token;\n                        if (!position.isBefore && position.isAfter) break;\n                    }\n                    if (currentCondensedToken.length > 0) condensedTokens.push(currentCondensedToken.trim());\n                    else condensedTokenIndex++;\n                }\n                return condensedTokens;\n                function tokenIsTagOrAdjacentToTag(index) {\n                    return {\n                        isBefore: tagIndices.includes(index + 1),\n                        isTag: tagIndices.includes(index),\n                        isAfter: tagIndices.includes(index - 1)\n                    };\n                }\n                function isTruthy(position) {\n                    return position.isBefore || position.isTag || position.isAfter;\n                }\n            }\n        }\n    }\n}\nclass $a6a072b13f8b7810$export$2e2bcd8739ae039 {\n    static{\n        this.search = $a6a072b13f8b7810$var$search;\n    }\n}\n\n});\nparcelRegister(\"gx5Hu\", function(module, exports) {\n// https://github.com/farzher/fuzzysort v3.0.2\n// UMD (Universal Module Definition) for fuzzysort\n((root, UMD)=>{\n    if (typeof define === \"function\" && define.amd) define([], UMD);\n    else if (0, module.exports) module.exports = UMD();\n    else root[\"fuzzysort\"] = UMD();\n})(module.exports, (_)=>{\n    \"use strict\";\n    var single = (search, target)=>{\n        if (!search || !target) return NULL;\n        var preparedSearch = getPreparedSearch(search);\n        if (!isPrepared(target)) target = getPrepared(target);\n        var searchBitflags = preparedSearch.bitflags;\n        if ((searchBitflags & target._bitflags) !== searchBitflags) return NULL;\n        return algorithm(preparedSearch, target);\n    };\n    var go = (search, targets, options)=>{\n        if (!search) return options?.all ? all(targets, options) : noResults;\n        var preparedSearch = getPreparedSearch(search);\n        var searchBitflags = preparedSearch.bitflags;\n        var containsSpace = preparedSearch.containsSpace;\n        var threshold = denormalizeScore(options?.threshold || 0);\n        var limit = options?.limit || INFINITY;\n        var resultsLen = 0;\n        var limitedCount = 0;\n        var targetsLen = targets.length;\n        function push_result(result) {\n            if (resultsLen < limit) {\n                q.add(result);\n                ++resultsLen;\n            } else {\n                ++limitedCount;\n                if (result._score > q.peek()._score) q.replaceTop(result);\n            }\n        }\n        // This code is copy/pasted 3 times for performance reasons [options.key, options.keys, no keys]\n        // options.key\n        if (options?.key) {\n            var key = options.key;\n            for(var i = 0; i < targetsLen; ++i){\n                var obj = targets[i];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isPrepared(target)) target = getPrepared(target);\n                if ((searchBitflags & target._bitflags) !== searchBitflags) continue;\n                var result = algorithm(preparedSearch, target);\n                if (result === NULL) continue;\n                if (result._score < threshold) continue;\n                result.obj = obj;\n                push_result(result);\n            }\n        // options.keys\n        } else if (options?.keys) {\n            var keys = options.keys;\n            var keysLen = keys.length;\n            outer: for(var i = 0; i < targetsLen; ++i){\n                var obj = targets[i];\n                var keysBitflags = 0;\n                for(var keyI = 0; keyI < keysLen; ++keyI){\n                    var key = keys[keyI];\n                    var target = getValue(obj, key);\n                    if (!target) {\n                        tmpTargets[keyI] = noTarget;\n                        continue;\n                    }\n                    if (!isPrepared(target)) target = getPrepared(target);\n                    tmpTargets[keyI] = target;\n                    keysBitflags |= target._bitflags;\n                }\n                if ((searchBitflags & keysBitflags) !== searchBitflags) continue;\n                if (containsSpace) for(let i = 0; i < preparedSearch.spaceSearches.length; i++)keysSpacesBestScores[i] = NEGATIVE_INFINITY;\n                for(var keyI = 0; keyI < keysLen; ++keyI){\n                    target = tmpTargets[keyI];\n                    if (target === noTarget) {\n                        tmpResults[keyI] = noTarget;\n                        continue;\n                    }\n                    tmpResults[keyI] = algorithm(preparedSearch, target, /*allowSpaces=*/ false, /*allowPartialMatch=*/ containsSpace);\n                    if (tmpResults[keyI] === NULL) {\n                        tmpResults[keyI] = noTarget;\n                        continue;\n                    }\n                    // todo: this seems weird and wrong. like what if our first match wasn't good. this should just replace it instead of averaging with it\n                    // if our second match isn't good we ignore it instead of averaging with it\n                    if (containsSpace) for(let i = 0; i < preparedSearch.spaceSearches.length; i++){\n                        if (allowPartialMatchScores[i] > -1000) {\n                            if (keysSpacesBestScores[i] > NEGATIVE_INFINITY) {\n                                var tmp = (keysSpacesBestScores[i] + allowPartialMatchScores[i]) / 4 /*bonus score for having multiple matches*/ ;\n                                if (tmp > keysSpacesBestScores[i]) keysSpacesBestScores[i] = tmp;\n                            }\n                        }\n                        if (allowPartialMatchScores[i] > keysSpacesBestScores[i]) keysSpacesBestScores[i] = allowPartialMatchScores[i];\n                    }\n                }\n                if (containsSpace) for(let i = 0; i < preparedSearch.spaceSearches.length; i++){\n                    if (keysSpacesBestScores[i] === NEGATIVE_INFINITY) continue outer;\n                }\n                else {\n                    var hasAtLeast1Match = false;\n                    for(let i = 0; i < keysLen; i++)if (tmpResults[i]._score !== NEGATIVE_INFINITY) {\n                        hasAtLeast1Match = true;\n                        break;\n                    }\n                    if (!hasAtLeast1Match) continue;\n                }\n                var objResults = new KeysResult(keysLen);\n                for(let i = 0; i < keysLen; i++)objResults[i] = tmpResults[i];\n                if (containsSpace) {\n                    var score = 0;\n                    for(let i = 0; i < preparedSearch.spaceSearches.length; i++)score += keysSpacesBestScores[i];\n                } else {\n                    // todo could rewrite this scoring to be more similar to when there's spaces\n                    // if we match multiple keys give us bonus points\n                    var score = NEGATIVE_INFINITY;\n                    for(let i = 0; i < keysLen; i++){\n                        var result = objResults[i];\n                        if (result._score > -1000) {\n                            if (score > NEGATIVE_INFINITY) {\n                                var tmp = (score + result._score) / 4 /*bonus score for having multiple matches*/ ;\n                                if (tmp > score) score = tmp;\n                            }\n                        }\n                        if (result._score > score) score = result._score;\n                    }\n                }\n                objResults.obj = obj;\n                objResults._score = score;\n                if (options?.scoreFn) {\n                    score = options.scoreFn(objResults);\n                    if (!score) continue;\n                    score = denormalizeScore(score);\n                    objResults._score = score;\n                }\n                if (score < threshold) continue;\n                push_result(objResults);\n            }\n        // no keys\n        } else for(var i = 0; i < targetsLen; ++i){\n            var target = targets[i];\n            if (!target) continue;\n            if (!isPrepared(target)) target = getPrepared(target);\n            if ((searchBitflags & target._bitflags) !== searchBitflags) continue;\n            var result = algorithm(preparedSearch, target);\n            if (result === NULL) continue;\n            if (result._score < threshold) continue;\n            push_result(result);\n        }\n        if (resultsLen === 0) return noResults;\n        var results = new Array(resultsLen);\n        for(var i = resultsLen - 1; i >= 0; --i)results[i] = q.poll();\n        results.total = resultsLen + limitedCount;\n        return results;\n    };\n    // this is written as 1 function instead of 2 for minification. perf seems fine ...\n    // except when minified. the perf is very slow\n    var highlight = (result, open = \"<b>\", close = \"</b>\")=>{\n        var callback = typeof open === \"function\" ? open : undefined;\n        var target = result.target;\n        var targetLen = target.length;\n        var indexes = result.indexes;\n        var highlighted = \"\";\n        var matchI = 0;\n        var indexesI = 0;\n        var opened = false;\n        var parts = [];\n        for(var i = 0; i < targetLen; ++i){\n            var char = target[i];\n            if (indexes[indexesI] === i) {\n                ++indexesI;\n                if (!opened) {\n                    opened = true;\n                    if (callback) {\n                        parts.push(highlighted);\n                        highlighted = \"\";\n                    } else highlighted += open;\n                }\n                if (indexesI === indexes.length) {\n                    if (callback) {\n                        highlighted += char;\n                        parts.push(callback(highlighted, matchI++));\n                        highlighted = \"\";\n                        parts.push(target.substr(i + 1));\n                    } else highlighted += char + close + target.substr(i + 1);\n                    break;\n                }\n            } else if (opened) {\n                opened = false;\n                if (callback) {\n                    parts.push(callback(highlighted, matchI++));\n                    highlighted = \"\";\n                } else highlighted += close;\n            }\n            highlighted += char;\n        }\n        return callback ? parts : highlighted;\n    };\n    var prepare = (target)=>{\n        if (typeof target === \"number\") target = \"\" + target;\n        else if (typeof target !== \"string\") target = \"\";\n        var info = prepareLowerInfo(target);\n        return new_result(target, {\n            _targetLower: info._lower,\n            _targetLowerCodes: info.lowerCodes,\n            _bitflags: info.bitflags\n        });\n    };\n    var cleanup = ()=>{\n        preparedCache.clear();\n        preparedSearchCache.clear();\n    };\n    // Below this point is only internal code\n    // Below this point is only internal code\n    // Below this point is only internal code\n    // Below this point is only internal code\n    class Result {\n        get [\"indexes\"]() {\n            return this._indexes.slice(0, this._indexes.len).sort((a, b)=>a - b);\n        }\n        set [\"indexes\"](indexes) {\n            return this._indexes = indexes;\n        }\n        [\"highlight\"](open, close) {\n            return highlight(this, open, close);\n        }\n        get [\"score\"]() {\n            return normalizeScore(this._score);\n        }\n        set [\"score\"](score) {\n            this._score = denormalizeScore(score);\n        }\n    }\n    class KeysResult extends Array {\n        get [\"score\"]() {\n            return normalizeScore(this._score);\n        }\n        set [\"score\"](score) {\n            this._score = denormalizeScore(score);\n        }\n    }\n    var new_result = (target, options)=>{\n        const result = new Result();\n        result[\"target\"] = target;\n        result[\"obj\"] = options.obj ?? NULL;\n        result._score = options._score ?? NEGATIVE_INFINITY;\n        result._indexes = options._indexes ?? [];\n        result._targetLower = options._targetLower ?? \"\";\n        result._targetLowerCodes = options._targetLowerCodes ?? NULL;\n        result._nextBeginningIndexes = options._nextBeginningIndexes ?? NULL;\n        result._bitflags = options._bitflags ?? 0;\n        return result;\n    };\n    var normalizeScore = (score)=>{\n        if (score === NEGATIVE_INFINITY) return 0;\n        if (score > 1) return score;\n        return Math.E ** (((-score + 1) ** .04307 - 1) * -2);\n    };\n    var denormalizeScore = (normalizedScore)=>{\n        if (normalizedScore === 0) return NEGATIVE_INFINITY;\n        if (normalizedScore > 1) return normalizedScore;\n        return 1 - Math.pow(Math.log(normalizedScore) / -2 + 1, 1 / 0.04307);\n    };\n    var prepareSearch = (search)=>{\n        if (typeof search === \"number\") search = \"\" + search;\n        else if (typeof search !== \"string\") search = \"\";\n        search = search.trim();\n        var info = prepareLowerInfo(search);\n        var spaceSearches = [];\n        if (info.containsSpace) {\n            var searches = search.split(/\\s+/);\n            searches = [\n                ...new Set(searches)\n            ] // distinct\n            ;\n            for(var i = 0; i < searches.length; i++){\n                if (searches[i] === \"\") continue;\n                var _info = prepareLowerInfo(searches[i]);\n                spaceSearches.push({\n                    lowerCodes: _info.lowerCodes,\n                    _lower: searches[i].toLowerCase(),\n                    containsSpace: false\n                });\n            }\n        }\n        return {\n            lowerCodes: info.lowerCodes,\n            _lower: info._lower,\n            containsSpace: info.containsSpace,\n            bitflags: info.bitflags,\n            spaceSearches: spaceSearches\n        };\n    };\n    var getPrepared = (target)=>{\n        if (target.length > 999) return prepare(target) // don't cache huge targets\n        ;\n        var targetPrepared = preparedCache.get(target);\n        if (targetPrepared !== undefined) return targetPrepared;\n        targetPrepared = prepare(target);\n        preparedCache.set(target, targetPrepared);\n        return targetPrepared;\n    };\n    var getPreparedSearch = (search)=>{\n        if (search.length > 999) return prepareSearch(search) // don't cache huge searches\n        ;\n        var searchPrepared = preparedSearchCache.get(search);\n        if (searchPrepared !== undefined) return searchPrepared;\n        searchPrepared = prepareSearch(search);\n        preparedSearchCache.set(search, searchPrepared);\n        return searchPrepared;\n    };\n    var all = (targets, options)=>{\n        var results = [];\n        results.total = targets.length // this total can be wrong if some targets are skipped\n        ;\n        var limit = options?.limit || INFINITY;\n        if (options?.key) for(var i = 0; i < targets.length; i++){\n            var obj = targets[i];\n            var target = getValue(obj, options.key);\n            if (target == NULL) continue;\n            if (!isPrepared(target)) target = getPrepared(target);\n            var result = new_result(target.target, {\n                _score: target._score,\n                obj: obj\n            });\n            results.push(result);\n            if (results.length >= limit) return results;\n        }\n        else if (options?.keys) for(var i = 0; i < targets.length; i++){\n            var obj = targets[i];\n            var objResults = new KeysResult(options.keys.length);\n            for(var keyI = options.keys.length - 1; keyI >= 0; --keyI){\n                var target = getValue(obj, options.keys[keyI]);\n                if (!target) {\n                    objResults[keyI] = noTarget;\n                    continue;\n                }\n                if (!isPrepared(target)) target = getPrepared(target);\n                target._score = NEGATIVE_INFINITY;\n                target._indexes.len = 0;\n                objResults[keyI] = target;\n            }\n            objResults.obj = obj;\n            objResults._score = NEGATIVE_INFINITY;\n            results.push(objResults);\n            if (results.length >= limit) return results;\n        }\n        else for(var i = 0; i < targets.length; i++){\n            var target = targets[i];\n            if (target == NULL) continue;\n            if (!isPrepared(target)) target = getPrepared(target);\n            target._score = NEGATIVE_INFINITY;\n            target._indexes.len = 0;\n            results.push(target);\n            if (results.length >= limit) return results;\n        }\n        return results;\n    };\n    var algorithm = (preparedSearch, prepared, allowSpaces = false, allowPartialMatch = false)=>{\n        if (allowSpaces === false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared, allowPartialMatch);\n        var searchLower = preparedSearch._lower;\n        var searchLowerCodes = preparedSearch.lowerCodes;\n        var searchLowerCode = searchLowerCodes[0];\n        var targetLowerCodes = prepared._targetLowerCodes;\n        var searchLen = searchLowerCodes.length;\n        var targetLen = targetLowerCodes.length;\n        var searchI = 0 // where we at\n        ;\n        var targetI = 0 // where you at\n        ;\n        var matchesSimpleLen = 0;\n        // very basic fuzzy match; to remove non-matching targets ASAP!\n        // walk through target. find sequential matches.\n        // if all chars aren't found then exit\n        for(;;){\n            var isMatch = searchLowerCode === targetLowerCodes[targetI];\n            if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[searchI];\n            }\n            ++targetI;\n            if (targetI >= targetLen) return NULL // Failed to find searchI\n            ;\n        }\n        var searchI = 0;\n        var successStrict = false;\n        var matchesStrictLen = 0;\n        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n        if (nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target);\n        targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n        // Our target string successfully matched all characters in sequence!\n        // Let's try a more advanced and strict test to improve the score\n        // only count it as a match if it's consecutive or a beginning character!\n        var backtrackCount = 0;\n        if (targetI !== targetLen) for(;;)if (targetI >= targetLen) {\n            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n            if (searchI <= 0) break; // We failed to push chars forward for a better match\n            ++backtrackCount;\n            if (backtrackCount > 200) break; // exponential backtracking is taking too long, just give up and return a bad match\n            --searchI;\n            var lastMatch = matchesStrict[--matchesStrictLen];\n            targetI = nextBeginningIndexes[lastMatch];\n        } else {\n            var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n            if (isMatch) {\n                matchesStrict[matchesStrictLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                }\n                ++targetI;\n            } else targetI = nextBeginningIndexes[targetI];\n        }\n        // check if it's a substring match\n        var substringIndex = searchLen <= 1 ? -1 : prepared._targetLower.indexOf(searchLower, matchesSimple[0]) // perf: this is slow\n        ;\n        var isSubstring = !!~substringIndex;\n        var isSubstringBeginning = !isSubstring ? false : substringIndex === 0 || prepared._nextBeginningIndexes[substringIndex - 1] === substringIndex;\n        // if it's a substring match but not at a beginning index, let's try to find a substring starting at a beginning index for a better score\n        if (isSubstring && !isSubstringBeginning) for(var i = 0; i < nextBeginningIndexes.length; i = nextBeginningIndexes[i]){\n            if (i <= substringIndex) continue;\n            for(var s = 0; s < searchLen; s++)if (searchLowerCodes[s] !== prepared._targetLowerCodes[i + s]) break;\n            if (s === searchLen) {\n                substringIndex = i;\n                isSubstringBeginning = true;\n                break;\n            }\n        }\n        // tally up the score & keep track of matches for highlighting later\n        // if it's a simple match, we'll switch to a substring match if a substring exists\n        // if it's a strict match, we'll switch to a substring match only if that's a better score\n        var calculateScore = (matches)=>{\n            var score = 0;\n            var extraMatchGroupCount = 0;\n            for(var i = 1; i < searchLen; ++i)if (matches[i] - matches[i - 1] !== 1) {\n                score -= matches[i];\n                ++extraMatchGroupCount;\n            }\n            var unmatchedDistance = matches[searchLen - 1] - matches[0] - (searchLen - 1);\n            score -= (12 + unmatchedDistance) * extraMatchGroupCount // penality for more groups\n            ;\n            if (matches[0] !== 0) score -= matches[0] * matches[0] * .2 // penality for not starting near the beginning\n            ;\n            if (!successStrict) score *= 1000;\n            else {\n                // successStrict on a target with too many beginning indexes loses points for being a bad target\n                var uniqueBeginningIndexes = 1;\n                for(var i = nextBeginningIndexes[0]; i < targetLen; i = nextBeginningIndexes[i])++uniqueBeginningIndexes;\n                if (uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes - 24) * 10 // quite arbitrary numbers here ...\n                ;\n            }\n            score -= (targetLen - searchLen) / 2 // penality for longer targets\n            ;\n            if (isSubstring) score /= 1 + searchLen * searchLen * 1 // bonus for being a full substring\n            ;\n            if (isSubstringBeginning) score /= 1 + searchLen * searchLen * 1 // bonus for substring starting on a beginningIndex\n            ;\n            score -= (targetLen - searchLen) / 2 // penality for longer targets\n            ;\n            return score;\n        };\n        if (!successStrict) {\n            if (isSubstring) for(var i = 0; i < searchLen; ++i)matchesSimple[i] = substringIndex + i // at this point it's safe to overwrite matchehsSimple with substr matches\n            ;\n            var matchesBest = matchesSimple;\n            var score = calculateScore(matchesBest);\n        } else if (isSubstringBeginning) {\n            for(var i = 0; i < searchLen; ++i)matchesSimple[i] = substringIndex + i // at this point it's safe to overwrite matchehsSimple with substr matches\n            ;\n            var matchesBest = matchesSimple;\n            var score = calculateScore(matchesSimple);\n        } else {\n            var matchesBest = matchesStrict;\n            var score = calculateScore(matchesStrict);\n        }\n        prepared._score = score;\n        for(var i = 0; i < searchLen; ++i)prepared._indexes[i] = matchesBest[i];\n        prepared._indexes.len = searchLen;\n        const result = new Result();\n        result.target = prepared.target;\n        result._score = prepared._score;\n        result._indexes = prepared._indexes;\n        return result;\n    };\n    var algorithmSpaces = (preparedSearch, target, allowPartialMatch)=>{\n        var seen_indexes = new Set();\n        var score = 0;\n        var result = NULL;\n        var first_seen_index_last_search = 0;\n        var searches = preparedSearch.spaceSearches;\n        var searchesLen = searches.length;\n        var changeslen = 0;\n        // Return _nextBeginningIndexes back to its normal state\n        var resetNextBeginningIndexes = ()=>{\n            for(let i = changeslen - 1; i >= 0; i--)target._nextBeginningIndexes[nextBeginningIndexesChanges[i * 2 + 0]] = nextBeginningIndexesChanges[i * 2 + 1];\n        };\n        var hasAtLeast1Match = false;\n        for(var i = 0; i < searchesLen; ++i){\n            allowPartialMatchScores[i] = NEGATIVE_INFINITY;\n            var search = searches[i];\n            result = algorithm(search, target);\n            if (allowPartialMatch) {\n                if (result === NULL) continue;\n                hasAtLeast1Match = true;\n            } else if (result === NULL) {\n                resetNextBeginningIndexes();\n                return NULL;\n            }\n            // if not the last search, we need to mutate _nextBeginningIndexes for the next search\n            var isTheLastSearch = i === searchesLen - 1;\n            if (!isTheLastSearch) {\n                var indexes = result._indexes;\n                var indexesIsConsecutiveSubstring = true;\n                for(let i = 0; i < indexes.len - 1; i++)if (indexes[i + 1] - indexes[i] !== 1) {\n                    indexesIsConsecutiveSubstring = false;\n                    break;\n                }\n                if (indexesIsConsecutiveSubstring) {\n                    var newBeginningIndex = indexes[indexes.len - 1] + 1;\n                    var toReplace = target._nextBeginningIndexes[newBeginningIndex - 1];\n                    for(let i = newBeginningIndex - 1; i >= 0; i--){\n                        if (toReplace !== target._nextBeginningIndexes[i]) break;\n                        target._nextBeginningIndexes[i] = newBeginningIndex;\n                        nextBeginningIndexesChanges[changeslen * 2 + 0] = i;\n                        nextBeginningIndexesChanges[changeslen * 2 + 1] = toReplace;\n                        changeslen++;\n                    }\n                }\n            }\n            score += result._score / searchesLen;\n            allowPartialMatchScores[i] = result._score / searchesLen;\n            // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\n            if (result._indexes[0] < first_seen_index_last_search) score -= (first_seen_index_last_search - result._indexes[0]) * 2;\n            first_seen_index_last_search = result._indexes[0];\n            for(var j = 0; j < result._indexes.len; ++j)seen_indexes.add(result._indexes[j]);\n        }\n        if (allowPartialMatch && !hasAtLeast1Match) return NULL;\n        resetNextBeginningIndexes();\n        // allows a search with spaces that's an exact substring to score well\n        var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/ true);\n        if (allowSpacesResult !== NULL && allowSpacesResult._score > score) {\n            if (allowPartialMatch) for(var i = 0; i < searchesLen; ++i)allowPartialMatchScores[i] = allowSpacesResult._score / searchesLen;\n            return allowSpacesResult;\n        }\n        if (allowPartialMatch) result = target;\n        result._score = score;\n        var i = 0;\n        for (let index of seen_indexes)result._indexes[i++] = index;\n        result._indexes.len = i;\n        return result;\n    };\n    var prepareLowerInfo = (str)=>{\n        var strLen = str.length;\n        var lower = str.toLowerCase();\n        var lowerCodes = [] // new Array(strLen)    sparse array is too slow\n        ;\n        var bitflags = 0;\n        var containsSpace = false // space isn't stored in bitflags because of how searching with a space works\n        ;\n        for(var i = 0; i < strLen; ++i){\n            var lowerCode = lowerCodes[i] = lower.charCodeAt(i);\n            if (lowerCode === 32) {\n                containsSpace = true;\n                continue; // it's important that we don't set any bitflags for space\n            }\n            var bit = lowerCode >= 97 && lowerCode <= 122 ? lowerCode - 97 // alphabet\n             : lowerCode >= 48 && lowerCode <= 57 ? 26 // numbers\n             : lowerCode <= 127 ? 30 // other ascii\n             : 31 // other utf8\n            ;\n            bitflags |= 1 << bit;\n        }\n        return {\n            lowerCodes: lowerCodes,\n            bitflags: bitflags,\n            containsSpace: containsSpace,\n            _lower: lower\n        };\n    };\n    var prepareBeginningIndexes = (target)=>{\n        var targetLen = target.length;\n        var beginningIndexes = [];\n        var beginningIndexesLen = 0;\n        var wasUpper = false;\n        var wasAlphanum = false;\n        for(var i = 0; i < targetLen; ++i){\n            var targetCode = target.charCodeAt(i);\n            var isUpper = targetCode >= 65 && targetCode <= 90;\n            var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n            var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n            wasUpper = isUpper;\n            wasAlphanum = isAlphanum;\n            if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n        }\n        return beginningIndexes;\n    };\n    var prepareNextBeginningIndexes = (target)=>{\n        var targetLen = target.length;\n        var beginningIndexes = prepareBeginningIndexes(target);\n        var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\n        ;\n        var lastIsBeginning = beginningIndexes[0];\n        var lastIsBeginningI = 0;\n        for(var i = 0; i < targetLen; ++i)if (lastIsBeginning > i) nextBeginningIndexes[i] = lastIsBeginning;\n        else {\n            lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n            nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n        }\n        return nextBeginningIndexes;\n    };\n    var preparedCache = new Map();\n    var preparedSearchCache = new Map();\n    // the theory behind these being globals is to reduce garbage collection by not making new arrays\n    var matchesSimple = [];\n    var matchesStrict = [];\n    var nextBeginningIndexesChanges = [] // allows straw berry to match strawberry well, by modifying the end of a substring to be considered a beginning index for the rest of the search\n    ;\n    var keysSpacesBestScores = [];\n    var allowPartialMatchScores = [];\n    var tmpTargets = [];\n    var tmpResults = [];\n    // prop = 'key'                  2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n    // prop = 'key1.key2'            10ms\n    // prop = ['key1', 'key2']       27ms\n    // prop = obj => obj.tags.join() ??ms\n    var getValue = (obj, prop)=>{\n        var tmp = obj[prop];\n        if (tmp !== undefined) return tmp;\n        if (typeof prop === \"function\") return prop(obj) // this should run first. but that makes string props slower\n        ;\n        var segs = prop;\n        if (!Array.isArray(prop)) segs = prop.split(\".\");\n        var len = segs.length;\n        var i = -1;\n        while(obj && ++i < len)obj = obj[segs[i]];\n        return obj;\n    };\n    var isPrepared = (x)=>{\n        return typeof x === \"object\" && typeof x._bitflags === \"number\";\n    };\n    var INFINITY = Infinity;\n    var NEGATIVE_INFINITY = -INFINITY;\n    var noResults = [];\n    noResults.total = 0;\n    var NULL = null;\n    var noTarget = prepare(\"\");\n    // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n    var fastpriorityqueue = (r)=>{\n        var e = [], o = 0, a = {}, v = (r)=>{\n            for(var a = 0, v = e[a], c = 1; c < o;){\n                var s = c + 1;\n                a = c, s < o && e[s]._score < e[c]._score && (a = s), e[a - 1 >> 1] = e[a], c = 1 + (a << 1);\n            }\n            for(var f = a - 1 >> 1; a > 0 && v._score < e[f]._score; f = (a = f) - 1 >> 1)e[a] = e[f];\n            e[a] = v;\n        };\n        return a.add = (r)=>{\n            var a = o;\n            e[o++] = r;\n            for(var v = a - 1 >> 1; a > 0 && r._score < e[v]._score; v = (a = v) - 1 >> 1)e[a] = e[v];\n            e[a] = r;\n        }, a.poll = (r)=>{\n            if (0 !== o) {\n                var a = e[0];\n                return e[0] = e[--o], v(), a;\n            }\n        }, a.peek = (r)=>{\n            if (0 !== o) return e[0];\n        }, a.replaceTop = (r)=>{\n            e[0] = r, v();\n        }, a;\n    };\n    var q = fastpriorityqueue() // reuse this\n    ;\n    // fuzzysort is written this way for minification. all names are mangeled unless quoted\n    return {\n        \"single\": single,\n        \"go\": go,\n        \"prepare\": prepare,\n        \"cleanup\": cleanup\n    };\n}) // UMD\n;\n\n});\n\n\n\nparcelRequire(\"kyWZn\");\n})();\n//# sourceMappingURL=SearchResults.js.map\n","import fuzzysort from 'fuzzysort';\nimport { SearchTarget } from '../lib/types/Searchable';\n\nconst SEARCH_RESULTS_HIGHLIGHT_CLASS = 'highlight';\n\ntype CompiledSearchResult = {\n    path: string;\n    score: number;\n    title: string;\n    highlightedTitleChunks: string[];\n    highlightedContentChunks: string[];\n};\n\nconst searchResultsCache: Map<string, CompiledSearchResult[]> = new Map();\nasync function search(query: string, searchTargets: SearchTarget[]): Promise<[CompiledSearchResult[], boolean]> {\n    const cacheResult = searchResultsCache.get(query);\n    return [\n        cacheResult\n        ?? await (async () => {\n            const compiledResults: CompiledSearchResult[] = await compileSearchResults(query, searchTargets);\n            searchResultsCache.set(query, compiledResults);\n            return compiledResults;\n        })(),\n        cacheResult !== undefined\n    ];\n    //\n    async function compileSearchResults(query: string, searchTargets: SearchTarget[]): Promise<CompiledSearchResult[]> {\n        const compiledResults: CompiledSearchResult[] = [];\n\n        //! PERFORMANCE\n        const fuzzysortStartTime = performance.now();\n        //! -----------\n        const results = fuzzysort.go(query, searchTargets, {\n            keys: ['title', 'content'],\n            all: true,\n        });\n        //! PERFORMANCE\n        const fuzzysortEndTime = performance.now();\n        //! -----------\n\n        //! PERFORMANCE\n        const compilationStartTime = performance.now();\n        //! -----------\n        results.forEach(result => {\n            compiledResults.push({\n                path: result.obj.path,\n                score: result.score,\n                title: result.obj.title.target,\n                highlightedTitleChunks: getHighlighted(query, result[0]),\n                highlightedContentChunks: getHighlighted(query, result[1]),\n            });\n        });\n        //! PERFORMANCE\n        const compilationEndTime = performance.now();\n        console.log('Fuzzysort took', fuzzysortEndTime - fuzzysortStartTime, 'ms');\n        console.log('Compilation took', compilationEndTime - compilationStartTime, 'ms');\n        //! -----------\n        return compiledResults;\n        //\n        function getHighlighted(query: string, result: Fuzzysort.Result): string[] {\n            const OPEN_TAG = `<span class=\"${SEARCH_RESULTS_HIGHLIGHT_CLASS}\">`;\n            const CLOSE_TAG = '</span>';\n\n            // preliminary highlight using fuzzysort highlight function\n            // this only cares about the first match and ignores the rest\n            const preHighlightedTokens = result.highlight((highlightText: string) => `${OPEN_TAG}${highlightText}${CLOSE_TAG}`);\n            if (preHighlightedTokens.length === 0) { return []; }\n\n            // highlight the rest, atomise them, and push them into the same array\n            const TAGGED_REGEX = new RegExp(String.raw`^${OPEN_TAG}.*${CLOSE_TAG}$`, 'g');\n            const comprehensiveTokens: string[] = getComprehensiveTokens(preHighlightedTokens);\n            const [atomicTokens, tagTokenIndices]: [string[], number[]] = atomiseTokens(comprehensiveTokens);\n\n            // condense the tokens\n            const condensedTokens: string[] = condenseTokens(atomicTokens, tagTokenIndices);\n\n            return condensedTokens;\n            //\n            function getComprehensiveTokens(inputTokens: string[]): string[] {\n                const compTokens: string[] = [];\n                inputTokens.forEach(token => {\n                    if (token.match(TAGGED_REGEX)) {\n                        // is tag\n                        compTokens.push(token);\n                    } else {\n                        // is sentences\n                        const taggedSentences = highlightMore(token);\n                        const tokenisedHighlightedSentences = tokeniseTaggedSentences(taggedSentences);\n                        compTokens.push(...tokenisedHighlightedSentences);\n                    }\n                });\n                return compTokens;\n                //\n                function highlightMore(text: string): string {\n                    const queries = query.split(' ').filter(word => word.length > 0);\n                    const comprehensiveQueryRegex = new RegExp(\n                        String.raw`(${queries.join('|')})`,\n                        'gi'\n                    );\n                    return text.replace(comprehensiveQueryRegex, `${OPEN_TAG}$1${CLOSE_TAG}`);\n                }\n                function tokeniseTaggedSentences(taggedSentences: string): string[] {\n                    const tagSplitRegex = new RegExp(String.raw`(?=${OPEN_TAG})|(?<=${CLOSE_TAG})`, 'g');\n                    return taggedSentences.split(tagSplitRegex);\n                }\n            }\n            function atomiseTokens(inputTokens: string[]): [string[], number[]] {\n                const tokens: string[] = [];\n                const tokenIndices: number[] = [];\n                inputTokens.forEach(token => {\n                    if (token.match(TAGGED_REGEX)) {\n                        // is tag\n                        tokenIndices.push(tokens.length);\n                        tokens.push(token);\n                    } else {\n                        // is sentences\n                        tokens.push(...tokeniseSentences(token));\n                    }\n                });\n                return [tokens, tokenIndices];\n                //\n                function tokeniseSentences(sentences: string): string[] {\n                    const tokens = sentences.split(/(?<=\\n|\\.\\s|\\?\\s|!\\s)/g).filter(sentence => sentence.length > 0);\n                    const paddedTokens = replaceNewlinesWithEmptyElements(tokens);\n                    return paddedTokens;\n                    //\n                    function replaceNewlinesWithEmptyElements(tokens: string[]): string[] {\n                        for (let i = 0; i < tokens.length; i++) {\n                            const splitTokens = tokens[i].split('\\n');\n                            if (splitTokens.length > 1) {\n                                const withEmptyElements: string[] = interweaveEmptyElements(splitTokens);\n                                tokens.splice(i, 1, ...withEmptyElements);\n                                i += withEmptyElements.length - 1;\n                            }\n                        }\n                        return tokens;\n                    }\n                    function interweaveEmptyElements(splitTokens: string[]) {\n                        const interweaved: string[] = [];\n                        for (let j = 0; j < splitTokens.length; j++) {\n                            interweaved.push(splitTokens[j]);\n                            if (j < splitTokens.length - 1) { interweaved.push(''); }\n                        }\n                        return interweaved;\n                    }\n                }\n            }\n            function condenseTokens(inputTokens: string[], tagIndices: number[]): string[] {\n                const condensedTokens: string[] = [];\n                let condensedTokenIndex = 0;\n                while (condensedTokenIndex < inputTokens.length) {\n                    let currentCondensedToken = '';\n                    let position: PositionBooleans;\n                    while (isTruthy(position = tokenIsTagOrAdjacentToTag(condensedTokenIndex))) {\n                        const token = inputTokens[condensedTokenIndex];\n                        if (token === undefined) { break; }\n                        condensedTokenIndex++;\n                        //\n                        currentCondensedToken += token;\n                        if (!position.isBefore && position.isAfter) { break; }\n                    }\n                    if (currentCondensedToken.length > 0) {\n                        condensedTokens.push(currentCondensedToken.trim());\n                    } else {\n                        condensedTokenIndex++;\n                    }\n                }\n                return condensedTokens;\n                //\n                type PositionBooleans = { isBefore: boolean, isTag: boolean, isAfter: boolean };\n                function tokenIsTagOrAdjacentToTag(index: number): PositionBooleans {\n                    return {\n                        isBefore: tagIndices.includes(index + 1),\n                        isTag: tagIndices.includes(index),\n                        isAfter: tagIndices.includes(index - 1),\n                    };\n                }\n                function isTruthy(position: PositionBooleans): boolean {\n                    return position.isBefore || position.isTag || position.isAfter;\n                }\n            }\n        }\n    }\n}\n\nexport default class SearchResults {\n    static search = search;\n}","// https://github.com/farzher/fuzzysort v3.0.2\r\n\r\n// UMD (Universal Module Definition) for fuzzysort\r\n;((root, UMD) => {\r\n  if(typeof define === 'function' && define.amd) define([], UMD)\r\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\r\n  else root['fuzzysort'] = UMD()\r\n})(this, _ => {\r\n  'use strict'\r\n\r\n  var single = (search, target) => {\r\n    if(!search || !target) return NULL\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n    var searchBitflags = preparedSearch.bitflags\r\n    if((searchBitflags & target._bitflags) !== searchBitflags) return NULL\r\n\r\n    return algorithm(preparedSearch, target)\r\n  }\r\n\r\n  var go = (search, targets, options) => {\r\n    if(!search) return options?.all ? all(targets, options) : noResults\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    var searchBitflags = preparedSearch.bitflags\r\n    var containsSpace  = preparedSearch.containsSpace\r\n\r\n    var threshold = denormalizeScore( options?.threshold || 0 )\r\n    var limit     = options?.limit || INFINITY\r\n\r\n    var resultsLen = 0; var limitedCount = 0\r\n    var targetsLen = targets.length\r\n\r\n    function push_result(result) {\r\n      if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n      else {\r\n        ++limitedCount\r\n        if(result._score > q.peek()._score) q.replaceTop(result)\r\n      }\r\n    }\r\n\r\n    // This code is copy/pasted 3 times for performance reasons [options.key, options.keys, no keys]\r\n\r\n    // options.key\r\n    if(options?.key) {\r\n      var key = options.key\r\n      for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n        var target = getValue(obj, key)\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        result.obj = obj\r\n        push_result(result)\r\n      }\r\n\r\n    // options.keys\r\n    } else if(options?.keys) {\r\n      var keys = options.keys\r\n      var keysLen = keys.length\r\n\r\n      outer: for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n\r\n        { // early out based on bitflags\r\n          var keysBitflags = 0\r\n          for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n            var key = keys[keyI]\r\n            var target = getValue(obj, key)\r\n            if(!target) { tmpTargets[keyI] = noTarget; continue }\r\n            if(!isPrepared(target)) target = getPrepared(target)\r\n            tmpTargets[keyI] = target\r\n\r\n            keysBitflags |= target._bitflags\r\n          }\r\n\r\n          if((searchBitflags & keysBitflags) !== searchBitflags) continue\r\n        }\r\n\r\n        if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) keysSpacesBestScores[i] = NEGATIVE_INFINITY\r\n\r\n        for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n          target = tmpTargets[keyI]\r\n          if(target === noTarget) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          tmpResults[keyI] = algorithm(preparedSearch, target, /*allowSpaces=*/false, /*allowPartialMatch=*/containsSpace)\r\n          if(tmpResults[keyI] === NULL) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          // todo: this seems weird and wrong. like what if our first match wasn't good. this should just replace it instead of averaging with it\r\n          // if our second match isn't good we ignore it instead of averaging with it\r\n          if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) {\r\n            if(allowPartialMatchScores[i] > -1000) {\r\n              if(keysSpacesBestScores[i] > NEGATIVE_INFINITY) {\r\n                var tmp = (keysSpacesBestScores[i] + allowPartialMatchScores[i]) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > keysSpacesBestScores[i]) keysSpacesBestScores[i] = tmp\r\n              }\r\n            }\r\n            if(allowPartialMatchScores[i] > keysSpacesBestScores[i]) keysSpacesBestScores[i] = allowPartialMatchScores[i]\r\n          }\r\n        }\r\n\r\n        if(containsSpace) {\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) { if(keysSpacesBestScores[i] === NEGATIVE_INFINITY) continue outer }\r\n        } else {\r\n          var hasAtLeast1Match = false\r\n          for(let i=0; i < keysLen; i++) { if(tmpResults[i]._score !== NEGATIVE_INFINITY) { hasAtLeast1Match = true; break } }\r\n          if(!hasAtLeast1Match) continue\r\n        }\r\n\r\n        var objResults = new KeysResult(keysLen)\r\n        for(let i=0; i < keysLen; i++) { objResults[i] = tmpResults[i] }\r\n\r\n        if(containsSpace) {\r\n          var score = 0\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) score += keysSpacesBestScores[i]\r\n        } else {\r\n          // todo could rewrite this scoring to be more similar to when there's spaces\r\n          // if we match multiple keys give us bonus points\r\n          var score = NEGATIVE_INFINITY\r\n          for(let i=0; i<keysLen; i++) {\r\n            var result = objResults[i]\r\n            if(result._score > -1000) {\r\n              if(score > NEGATIVE_INFINITY) {\r\n                var tmp = (score + result._score) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > score) score = tmp\r\n              }\r\n            }\r\n            if(result._score > score) score = result._score\r\n          }\r\n        }\r\n\r\n        objResults.obj = obj\r\n        objResults._score = score\r\n        if(options?.scoreFn) {\r\n          score = options.scoreFn(objResults)\r\n          if(!score) continue\r\n          score = denormalizeScore(score)\r\n          objResults._score = score\r\n        }\r\n\r\n        if(score < threshold) continue\r\n        push_result(objResults)\r\n      }\r\n\r\n    // no keys\r\n    } else {\r\n      for(var i = 0; i < targetsLen; ++i) { var target = targets[i]\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        push_result(result)\r\n      }\r\n    }\r\n\r\n    if(resultsLen === 0) return noResults\r\n    var results = new Array(resultsLen)\r\n    for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n    results.total = resultsLen + limitedCount\r\n    return results\r\n  }\r\n\r\n\r\n  // this is written as 1 function instead of 2 for minification. perf seems fine ...\r\n  // except when minified. the perf is very slow\r\n  var highlight = (result, open='<b>', close='</b>') => {\r\n    var callback = typeof open === 'function' ? open : undefined\r\n\r\n    var target      = result.target\r\n    var targetLen   = target.length\r\n    var indexes     = result.indexes\r\n    var highlighted = ''\r\n    var matchI      = 0\r\n    var indexesI    = 0\r\n    var opened      = false\r\n    var parts       = []\r\n\r\n    for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n      if(indexes[indexesI] === i) {\r\n        ++indexesI\r\n        if(!opened) { opened = true\r\n          if(callback) {\r\n            parts.push(highlighted); highlighted = ''\r\n          } else {\r\n            highlighted += open\r\n          }\r\n        }\r\n\r\n        if(indexesI === indexes.length) {\r\n          if(callback) {\r\n            highlighted += char\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n            parts.push(target.substr(i+1))\r\n          } else {\r\n            highlighted += char + close + target.substr(i+1)\r\n          }\r\n          break\r\n        }\r\n      } else {\r\n        if(opened) { opened = false\r\n          if(callback) {\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n          } else {\r\n            highlighted += close\r\n          }\r\n        }\r\n      }\r\n      highlighted += char\r\n    }\r\n\r\n    return callback ? parts : highlighted\r\n  }\r\n\r\n\r\n  var prepare = (target) => {\r\n    if(typeof target === 'number') target = ''+target\r\n    else if(typeof target !== 'string') target = ''\r\n    var info = prepareLowerInfo(target)\r\n    return new_result(target, {_targetLower:info._lower, _targetLowerCodes:info.lowerCodes, _bitflags:info.bitflags})\r\n  }\r\n\r\n  var cleanup = () => { preparedCache.clear(); preparedSearchCache.clear() }\r\n\r\n\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n\r\n\r\n  class Result {\r\n    get ['indexes']() { return this._indexes.slice(0, this._indexes.len).sort((a,b)=>a-b) }\r\n    set ['indexes'](indexes) { return this._indexes = indexes }\r\n    ['highlight'](open, close) { return highlight(this, open, close) }\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  class KeysResult extends Array {\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  var new_result = (target, options) => {\r\n    const result = new Result()\r\n    result['target']             = target\r\n    result['obj']                = options.obj                   ?? NULL\r\n    result._score                = options._score                ?? NEGATIVE_INFINITY\r\n    result._indexes              = options._indexes              ?? []\r\n    result._targetLower          = options._targetLower          ?? ''\r\n    result._targetLowerCodes     = options._targetLowerCodes     ?? NULL\r\n    result._nextBeginningIndexes = options._nextBeginningIndexes ?? NULL\r\n    result._bitflags             = options._bitflags             ?? 0\r\n    return result\r\n  }\r\n\r\n\r\n  var normalizeScore = score => {\r\n    if(score === NEGATIVE_INFINITY) return 0\r\n    if(score > 1) return score\r\n    return Math.E ** ( ((-score + 1)**.04307 - 1) * -2)\r\n  }\r\n  var denormalizeScore = normalizedScore => {\r\n    if(normalizedScore === 0) return NEGATIVE_INFINITY\r\n    if(normalizedScore > 1) return normalizedScore\r\n    return 1 - Math.pow((Math.log(normalizedScore) / -2 + 1), 1 / 0.04307)\r\n  }\r\n\r\n\r\n  var prepareSearch = (search) => {\r\n    if(typeof search === 'number') search = ''+search\r\n    else if(typeof search !== 'string') search = ''\r\n    search = search.trim()\r\n    var info = prepareLowerInfo(search)\r\n\r\n    var spaceSearches = []\r\n    if(info.containsSpace) {\r\n      var searches = search.split(/\\s+/)\r\n      searches = [...new Set(searches)] // distinct\r\n      for(var i=0; i<searches.length; i++) {\r\n        if(searches[i] === '') continue\r\n        var _info = prepareLowerInfo(searches[i])\r\n        spaceSearches.push({lowerCodes:_info.lowerCodes, _lower:searches[i].toLowerCase(), containsSpace:false})\r\n      }\r\n    }\r\n\r\n    return {lowerCodes: info.lowerCodes, _lower: info._lower, containsSpace: info.containsSpace, bitflags: info.bitflags, spaceSearches: spaceSearches}\r\n  }\r\n\r\n\r\n\r\n  var getPrepared = (target) => {\r\n    if(target.length > 999) return prepare(target) // don't cache huge targets\r\n    var targetPrepared = preparedCache.get(target)\r\n    if(targetPrepared !== undefined) return targetPrepared\r\n    targetPrepared = prepare(target)\r\n    preparedCache.set(target, targetPrepared)\r\n    return targetPrepared\r\n  }\r\n  var getPreparedSearch = (search) => {\r\n    if(search.length > 999) return prepareSearch(search) // don't cache huge searches\r\n    var searchPrepared = preparedSearchCache.get(search)\r\n    if(searchPrepared !== undefined) return searchPrepared\r\n    searchPrepared = prepareSearch(search)\r\n    preparedSearchCache.set(search, searchPrepared)\r\n    return searchPrepared\r\n  }\r\n\r\n\r\n  var all = (targets, options) => {\r\n    var results = []; results.total = targets.length // this total can be wrong if some targets are skipped\r\n\r\n    var limit = options?.limit || INFINITY\r\n\r\n    if(options?.key) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var target = getValue(obj, options.key)\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        var result = new_result(target.target, {_score: target._score, obj: obj})\r\n        results.push(result); if(results.length >= limit) return results\r\n      }\r\n    } else if(options?.keys) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var objResults = new KeysResult(options.keys.length)\r\n        for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {\r\n          var target = getValue(obj, options.keys[keyI])\r\n          if(!target) { objResults[keyI] = noTarget; continue }\r\n          if(!isPrepared(target)) target = getPrepared(target)\r\n          target._score = NEGATIVE_INFINITY\r\n          target._indexes.len = 0\r\n          objResults[keyI] = target\r\n        }\r\n        objResults.obj = obj\r\n        objResults._score = NEGATIVE_INFINITY\r\n        results.push(objResults); if(results.length >= limit) return results\r\n      }\r\n    } else {\r\n      for(var i=0;i<targets.length;i++) { var target = targets[i]\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        target._score = NEGATIVE_INFINITY\r\n        target._indexes.len = 0\r\n        results.push(target); if(results.length >= limit) return results\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n\r\n  var algorithm = (preparedSearch, prepared, allowSpaces=false, allowPartialMatch=false) => {\r\n    if(allowSpaces===false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared, allowPartialMatch)\r\n\r\n    var searchLower      = preparedSearch._lower\r\n    var searchLowerCodes = preparedSearch.lowerCodes\r\n    var searchLowerCode  = searchLowerCodes[0]\r\n    var targetLowerCodes = prepared._targetLowerCodes\r\n    var searchLen        = searchLowerCodes.length\r\n    var targetLen        = targetLowerCodes.length\r\n    var searchI          = 0 // where we at\r\n    var targetI          = 0 // where you at\r\n    var matchesSimpleLen = 0\r\n\r\n    // very basic fuzzy match; to remove non-matching targets ASAP!\r\n    // walk through target. find sequential matches.\r\n    // if all chars aren't found then exit\r\n    for(;;) {\r\n      var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n      if(isMatch) {\r\n        matchesSimple[matchesSimpleLen++] = targetI\r\n        ++searchI; if(searchI === searchLen) break\r\n        searchLowerCode = searchLowerCodes[searchI]\r\n      }\r\n      ++targetI; if(targetI >= targetLen) return NULL // Failed to find searchI\r\n    }\r\n\r\n    var searchI = 0\r\n    var successStrict = false\r\n    var matchesStrictLen = 0\r\n\r\n    var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n    if(nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target)\r\n    targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n    // Our target string successfully matched all characters in sequence!\r\n    // Let's try a more advanced and strict test to improve the score\r\n    // only count it as a match if it's consecutive or a beginning character!\r\n    var backtrackCount = 0\r\n    if(targetI !== targetLen) for(;;) {\r\n      if(targetI >= targetLen) {\r\n        // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n        if(searchI <= 0) break // We failed to push chars forward for a better match\r\n\r\n        ++backtrackCount; if(backtrackCount > 200) break // exponential backtracking is taking too long, just give up and return a bad match\r\n\r\n        --searchI\r\n        var lastMatch = matchesStrict[--matchesStrictLen]\r\n        targetI = nextBeginningIndexes[lastMatch]\r\n\r\n      } else {\r\n        var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesStrict[matchesStrictLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n          ++targetI\r\n        } else {\r\n          targetI = nextBeginningIndexes[targetI]\r\n        }\r\n      }\r\n    }\r\n\r\n    // check if it's a substring match\r\n    var substringIndex = searchLen <= 1 ? -1 : prepared._targetLower.indexOf(searchLower, matchesSimple[0]) // perf: this is slow\r\n    var isSubstring = !!~substringIndex\r\n    var isSubstringBeginning = !isSubstring ? false : substringIndex===0 || prepared._nextBeginningIndexes[substringIndex-1] === substringIndex\r\n\r\n    // if it's a substring match but not at a beginning index, let's try to find a substring starting at a beginning index for a better score\r\n    if(isSubstring && !isSubstringBeginning) {\r\n      for(var i=0; i<nextBeginningIndexes.length; i=nextBeginningIndexes[i]) {\r\n        if(i <= substringIndex) continue\r\n\r\n        for(var s=0; s<searchLen; s++) if(searchLowerCodes[s] !== prepared._targetLowerCodes[i+s]) break\r\n        if(s === searchLen) { substringIndex = i; isSubstringBeginning = true; break }\r\n      }\r\n    }\r\n\r\n    // tally up the score & keep track of matches for highlighting later\r\n    // if it's a simple match, we'll switch to a substring match if a substring exists\r\n    // if it's a strict match, we'll switch to a substring match only if that's a better score\r\n\r\n    var calculateScore = matches => {\r\n      var score = 0\r\n\r\n      var extraMatchGroupCount = 0\r\n      for(var i = 1; i < searchLen; ++i) {\r\n        if(matches[i] - matches[i-1] !== 1) {score -= matches[i]; ++extraMatchGroupCount}\r\n      }\r\n      var unmatchedDistance = matches[searchLen-1] - matches[0] - (searchLen-1)\r\n\r\n      score -= (12+unmatchedDistance) * extraMatchGroupCount // penality for more groups\r\n\r\n      if(matches[0] !== 0) score -= matches[0]*matches[0]*.2 // penality for not starting near the beginning\r\n\r\n      if(!successStrict) {\r\n        score *= 1000\r\n      } else {\r\n        // successStrict on a target with too many beginning indexes loses points for being a bad target\r\n        var uniqueBeginningIndexes = 1\r\n        for(var i = nextBeginningIndexes[0]; i < targetLen; i=nextBeginningIndexes[i]) ++uniqueBeginningIndexes\r\n\r\n        if(uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes-24)*10 // quite arbitrary numbers here ...\r\n      }\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      if(isSubstring)          score /= 1+searchLen*searchLen*1 // bonus for being a full substring\r\n      if(isSubstringBeginning) score /= 1+searchLen*searchLen*1 // bonus for substring starting on a beginningIndex\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      return score\r\n    }\r\n\r\n    if(!successStrict) {\r\n      if(isSubstring) for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n      var matchesBest = matchesSimple\r\n      var score = calculateScore(matchesBest)\r\n    } else {\r\n      if(isSubstringBeginning) {\r\n        for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n        var matchesBest = matchesSimple\r\n        var score = calculateScore(matchesSimple)\r\n      } else {\r\n        var matchesBest = matchesStrict\r\n        var score = calculateScore(matchesStrict)\r\n      }\r\n    }\r\n\r\n    prepared._score = score\r\n\r\n    for(var i = 0; i < searchLen; ++i) prepared._indexes[i] = matchesBest[i]\r\n    prepared._indexes.len = searchLen\r\n\r\n    const result    = new Result()\r\n    result.target   = prepared.target\r\n    result._score   = prepared._score\r\n    result._indexes = prepared._indexes\r\n    return result\r\n  }\r\n  var algorithmSpaces = (preparedSearch, target, allowPartialMatch) => {\r\n    var seen_indexes = new Set()\r\n    var score = 0\r\n    var result = NULL\r\n\r\n    var first_seen_index_last_search = 0\r\n    var searches = preparedSearch.spaceSearches\r\n    var searchesLen = searches.length\r\n    var changeslen = 0\r\n\r\n    // Return _nextBeginningIndexes back to its normal state\r\n    var resetNextBeginningIndexes = () => {\r\n      for(let i=changeslen-1; i>=0; i--) target._nextBeginningIndexes[nextBeginningIndexesChanges[i*2 + 0]] = nextBeginningIndexesChanges[i*2 + 1]\r\n    }\r\n\r\n    var hasAtLeast1Match = false\r\n    for(var i=0; i<searchesLen; ++i) {\r\n      allowPartialMatchScores[i] = NEGATIVE_INFINITY\r\n      var search = searches[i]\r\n\r\n      result = algorithm(search, target)\r\n      if(allowPartialMatch) {\r\n        if(result === NULL) continue\r\n        hasAtLeast1Match = true\r\n      } else {\r\n        if(result === NULL) {resetNextBeginningIndexes(); return NULL}\r\n      }\r\n\r\n      // if not the last search, we need to mutate _nextBeginningIndexes for the next search\r\n      var isTheLastSearch = i === searchesLen - 1\r\n      if(!isTheLastSearch) {\r\n        var indexes = result._indexes\r\n\r\n        var indexesIsConsecutiveSubstring = true\r\n        for(let i=0; i<indexes.len-1; i++) {\r\n          if(indexes[i+1] - indexes[i] !== 1) {\r\n            indexesIsConsecutiveSubstring = false; break;\r\n          }\r\n        }\r\n\r\n        if(indexesIsConsecutiveSubstring) {\r\n          var newBeginningIndex = indexes[indexes.len-1] + 1\r\n          var toReplace = target._nextBeginningIndexes[newBeginningIndex-1]\r\n          for(let i=newBeginningIndex-1; i>=0; i--) {\r\n            if(toReplace !== target._nextBeginningIndexes[i]) break\r\n            target._nextBeginningIndexes[i] = newBeginningIndex\r\n            nextBeginningIndexesChanges[changeslen*2 + 0] = i\r\n            nextBeginningIndexesChanges[changeslen*2 + 1] = toReplace\r\n            changeslen++\r\n          }\r\n        }\r\n      }\r\n\r\n      score += result._score / searchesLen\r\n      allowPartialMatchScores[i] = result._score / searchesLen\r\n\r\n      // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\r\n      if(result._indexes[0] < first_seen_index_last_search) {\r\n        score -= (first_seen_index_last_search - result._indexes[0]) * 2\r\n      }\r\n      first_seen_index_last_search = result._indexes[0]\r\n\r\n      for(var j=0; j<result._indexes.len; ++j) seen_indexes.add(result._indexes[j])\r\n    }\r\n\r\n    if(allowPartialMatch && !hasAtLeast1Match) return NULL\r\n\r\n    resetNextBeginningIndexes()\r\n\r\n    // allows a search with spaces that's an exact substring to score well\r\n    var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/true)\r\n    if(allowSpacesResult !== NULL && allowSpacesResult._score > score) {\r\n      if(allowPartialMatch) {\r\n        for(var i=0; i<searchesLen; ++i) {\r\n          allowPartialMatchScores[i] = allowSpacesResult._score / searchesLen\r\n        }\r\n      }\r\n      return allowSpacesResult\r\n    }\r\n\r\n    if(allowPartialMatch) result = target\r\n    result._score = score\r\n\r\n    var i = 0\r\n    for (let index of seen_indexes) result._indexes[i++] = index\r\n    result._indexes.len = i\r\n\r\n    return result\r\n  }\r\n\r\n\r\n  var prepareLowerInfo = (str) => {\r\n    var strLen = str.length\r\n    var lower = str.toLowerCase()\r\n    var lowerCodes = [] // new Array(strLen)    sparse array is too slow\r\n    var bitflags = 0\r\n    var containsSpace = false // space isn't stored in bitflags because of how searching with a space works\r\n\r\n    for(var i = 0; i < strLen; ++i) {\r\n      var lowerCode = lowerCodes[i] = lower.charCodeAt(i)\r\n\r\n      if(lowerCode === 32) {\r\n        containsSpace = true\r\n        continue // it's important that we don't set any bitflags for space\r\n      }\r\n\r\n      var bit = lowerCode>=97&&lowerCode<=122 ? lowerCode-97 // alphabet\r\n              : lowerCode>=48&&lowerCode<=57  ? 26           // numbers\r\n                                                             // 3 bits available\r\n              : lowerCode<=127                ? 30           // other ascii\r\n              :                                 31           // other utf8\r\n      bitflags |= 1<<bit\r\n    }\r\n\r\n    return {lowerCodes:lowerCodes, bitflags:bitflags, containsSpace:containsSpace, _lower:lower}\r\n  }\r\n  var prepareBeginningIndexes = (target) => {\r\n    var targetLen = target.length\r\n    var beginningIndexes = []; var beginningIndexesLen = 0\r\n    var wasUpper = false\r\n    var wasAlphanum = false\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      var targetCode = target.charCodeAt(i)\r\n      var isUpper = targetCode>=65&&targetCode<=90\r\n      var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\r\n      var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\r\n      wasUpper = isUpper\r\n      wasAlphanum = isAlphanum\r\n      if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\r\n    }\r\n    return beginningIndexes\r\n  }\r\n  var prepareNextBeginningIndexes = (target) => {\r\n    var targetLen = target.length\r\n    var beginningIndexes = prepareBeginningIndexes(target)\r\n    var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\r\n    var lastIsBeginning = beginningIndexes[0]\r\n    var lastIsBeginningI = 0\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      if(lastIsBeginning > i) {\r\n        nextBeginningIndexes[i] = lastIsBeginning\r\n      } else {\r\n        lastIsBeginning = beginningIndexes[++lastIsBeginningI]\r\n        nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\r\n      }\r\n    }\r\n    return nextBeginningIndexes\r\n  }\r\n\r\n  var preparedCache       = new Map()\r\n  var preparedSearchCache = new Map()\r\n\r\n  // the theory behind these being globals is to reduce garbage collection by not making new arrays\r\n  var matchesSimple = []; var matchesStrict = []\r\n  var nextBeginningIndexesChanges = [] // allows straw berry to match strawberry well, by modifying the end of a substring to be considered a beginning index for the rest of the search\r\n  var keysSpacesBestScores = []; var allowPartialMatchScores = []\r\n  var tmpTargets = []; var tmpResults = []\r\n\r\n  // prop = 'key'                  2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\r\n  // prop = 'key1.key2'            10ms\r\n  // prop = ['key1', 'key2']       27ms\r\n  // prop = obj => obj.tags.join() ??ms\r\n  var getValue = (obj, prop) => {\r\n    var tmp = obj[prop]; if(tmp !== undefined) return tmp\r\n    if(typeof prop === 'function') return prop(obj) // this should run first. but that makes string props slower\r\n    var segs = prop\r\n    if(!Array.isArray(prop)) segs = prop.split('.')\r\n    var len = segs.length\r\n    var i = -1\r\n    while (obj && (++i < len)) obj = obj[segs[i]]\r\n    return obj\r\n  }\r\n\r\n  var isPrepared = (x) => { return typeof x === 'object' && typeof x._bitflags === 'number' }\r\n  var INFINITY = Infinity; var NEGATIVE_INFINITY = -INFINITY\r\n  var noResults = []; noResults.total = 0\r\n  var NULL = null\r\n\r\n  var noTarget = prepare('')\r\n\r\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\r\n  var fastpriorityqueue=r=>{var e=[],o=0,a={},v=r=>{for(var a=0,v=e[a],c=1;c<o;){var s=c+1;a=c,s<o&&e[s]._score<e[c]._score&&(a=s),e[a-1>>1]=e[a],c=1+(a<<1)}for(var f=a-1>>1;a>0&&v._score<e[f]._score;f=(a=f)-1>>1)e[a]=e[f];e[a]=v};return a.add=(r=>{var a=o;e[o++]=r;for(var v=a-1>>1;a>0&&r._score<e[v]._score;v=(a=v)-1>>1)e[a]=e[v];e[a]=r}),a.poll=(r=>{if(0!==o){var a=e[0];return e[0]=e[--o],v(),a}}),a.peek=(r=>{if(0!==o)return e[0]}),a.replaceTop=(r=>{e[0]=r,v()}),a}\r\n  var q = fastpriorityqueue() // reuse this\r\n\r\n  // fuzzysort is written this way for minification. all names are mangeled unless quoted\r\n  return {'single':single, 'go':go, 'prepare':prepare, 'cleanup':cleanup}\r\n}) // UMD\r\n"],"names":["$parcel$global","$parcel$modules","$parcel$inits","parcelRequire","parcelRegister","globalThis","id","exports","init","module","call","err","Error","code","register","Object","defineProperty","get","$a6a072b13f8b7810$export$2e2bcd8739ae039","set","s","enumerable","configurable","$gx5Hu","$a6a072b13f8b7810$var$searchResultsCache","Map","$a6a072b13f8b7810$var$search","query","searchTargets","cacheResult","compiledResults","compileSearchResults","undefined","fuzzysortStartTime","performance","now","results","a","__esModule","default","go","keys","all","fuzzysortEndTime","compilationStartTime","forEach","result","push","path","obj","score","title","target","highlightedTitleChunks","getHighlighted","highlightedContentChunks","compilationEndTime","console","log","OPEN_TAG","CLOSE_TAG","preHighlightedTokens","highlight","highlightText","length","TAGGED_REGEX","RegExp","String","raw","atomicTokens","tagTokenIndices","atomiseTokens","inputTokens","tokens","tokenIndices","token","match","replaceNewlinesWithEmptyElements","i","splitTokens","split","withEmptyElements","interweaveEmptyElements","interweaved","j","splice","sentences","filter","sentence","getComprehensiveTokens","compTokens","tokenisedHighlightedSentences","tokeniseTaggedSentences","taggedSentences","tagSplitRegex","highlightMore","text","queries","word","comprehensiveQueryRegex","join","replace","condenseTokens","tagIndices","condensedTokens","condensedTokenIndex","index","position","currentCondensedToken","isBefore","includes","isTag","isAfter","trim","search","root","UMD","_","e","o","v","open","close","callback","targetLen","indexes","highlighted","matchI","indexesI","opened","parts","char","substr","prepare","info","prepareLowerInfo","new_result","_targetLower","_lower","_targetLowerCodes","lowerCodes","_bitflags","bitflags","Result","_indexes","slice","len","sort","b","normalizeScore","_score","denormalizeScore","KeysResult","Array","options","NULL","NEGATIVE_INFINITY","_nextBeginningIndexes","Math","E","normalizedScore","pow","prepareSearch","spaceSearches","containsSpace","searches","Set","_info","toLowerCase","getPrepared","targetPrepared","preparedCache","getPreparedSearch","searchPrepared","preparedSearchCache","targets","total","limit","INFINITY","key","getValue","isPrepared","objResults","keyI","noTarget","algorithm","preparedSearch","prepared","allowSpaces","allowPartialMatch","algorithmSpaces","searchLower","searchLowerCodes","searchLowerCode","targetLowerCodes","searchLen","searchI","targetI","matchesSimpleLen","isMatch","matchesSimple","successStrict","matchesStrictLen","nextBeginningIndexes","prepareNextBeginningIndexes","backtrackCount","matchesStrict","substringIndex","indexOf","isSubstring","isSubstringBeginning","calculateScore","matches","extraMatchGroupCount","uniqueBeginningIndexes","matchesBest","seen_indexes","first_seen_index_last_search","searchesLen","changeslen","resetNextBeginningIndexes","nextBeginningIndexesChanges","hasAtLeast1Match","allowPartialMatchScores","indexesIsConsecutiveSubstring","newBeginningIndex","toReplace","add","allowSpacesResult","str","strLen","lower","lowerCode","charCodeAt","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","keysSpacesBestScores","tmpTargets","tmpResults","prop","tmp","segs","isArray","x","Infinity","noResults","q","r","c","f","poll","peek","replaceTop","searchBitflags","threshold","resultsLen","limitedCount","targetsLen","push_result","keysLen","outer","keysBitflags","scoreFn","clear","define","amd"],"version":3,"file":"SearchResults.js.map"}